/* 서버에서 넘어온 데이터를 저장할 수 있도록 foodLike 라는 변수를 만들고 빈 배열을 할당하자. 그리고
 * App 컴포넌트에 작성했던 Food 컴포넌트는 모두 삭제해 주자. 
 * 효율적인 컴포넌트를 만들려면, 우선 map 함수의 특징을 알아야 한다. map 함수는 배열을 모든 원소마다
 * 특정 작업을 하는 함수를 적용하고 그 반환값을 모아 배열을 생성해 반환한다. 반환이 없는 경우 map
 * 함수는 아무런 기능도 하지 않음에 주의한다. return 을 명시하거나 화살표 함수를 이용해 배열의 값을
 * 변화시킬 수 있다. 
 * ※ dish.name 이란, map 함수를 이용해 전달된 배열의 원소가 객체일 때, 이 객체의 name 타입에 해당하-
 * 는 값이라는 뜻이다. 햇갈리지 않도록 주의한다. 
 * App.js 파일 내에는 가능하면 최소한의 함수, 컴포넌트만 작성해야 나중에 관리하기가 편해진다. 
 * 
 * [map 함수의 key props 추가하기] 
 * - 리액트의 모든 원소들은 유일해야 하며, 이를 위해 키(key)값을 가져야 한다. 만약 key 값을 추가하지
 * 않으면 개발자 도구에 경고 표시가 뜨게 된다. 
 * 이 문제를 해결하기 위해 id라는 값을 추가하여 key값이 없다는 경고 메시지를 해결해 보자. 
 * 데이터에 id를 추가하는 이유는 리액트가 제공받은 배열의 각 객체를 서로 구분하기 위함이다. 각 컴포-
 * 넌트가 서로 다르다는 것을 알려주기 위해 컴포넌트에 key props를 추가하는 것이다. 
 * key값은 리액트 내부에서 사용되는 특수한 props이므로 Food 컴포넌트에 직접적으로 전달되지 않는다. 
 * 
 * [prop-types 도입하기]
 * - props와 map 함수의 사용 방법에 대해 어느 정도 알아보았다. 그런데 우리가 정의한 props 값이 컴포-
 * 넌트에 제대로 전달되지 않을 수 있다. 예를 들어 picture props에 {dish.image}가 아닌 {true}를 전달-
 * 한다면 이미지가 제대로 표시되지 않을 것이다. 이런 경우 전달한 props를 검사하는 방법이 필요하다. 
 * foodLike에 데이터를 좀 더 추가해 보자. 그래야 props를 검사하는 과정이 의미가 있어진다. 예를 들어
 * 음식 앱에 '평점'이라는 항목이 있다고 가정해 보자.
 * 
 * [음식 데이터에 rating 추가하기]
 * - foodLike 배열의 각 요소에 rating(평점)을 추가하자. 값의 자료형은 Number로 설정한다. 
 * rating이 포함된 음식 데이터가 준비되었다면, 이제 rating props를 Food 컴포넌트에 전달하면서 이 값-
 * 을 검사해 볼 것이다. 그러려면 props의 자료형을 검사할 수 있도록 만들어 주는 prop-types라는 도구-
 * 를 설치해야 한다. 명령어를 입력하여 prop-types를 설치하자. 
 * package.json 파일을 열어 다음처럼 설정이 되어있다면 설치가 잘 된 것이다. prop-types는 컴포넌트가
 * 전달받은 props가 정말 내가 원하는 값인지 확인해 준다. 개발자가 실수로 다른 props를 보낼 경우 오류
 * 메시지를 띄워 준다. 
 * 
 * [prop-types 적용하기]
 * - App 컴포넌트에 prop-types를 적용해 보자. 
 * 다음과 같이 Food.propTypes를 작성해 보자. 모든 props는 문자열이고 반드시 있어야 한다는 조건을 추-
 * 가했다. 이게 무엇인지는 프로그램을 실행한 다음 알아보자. 
 * 
 * [prop-types의 다양한 사용법 찾아보기]
 * - prop-types 공식 문서에 접속하여 중간에 있는 Usage를 살펴보자. 그러면 다양한 prop-types의 예시를
 * 볼 수 있다. 이제 앞으로 영화 앱을 만들면서 prop-types를 더 적극적으로 사용해볼 것이다. 다음 시간-
 * 에는 컴포넌트의 또 다른 핵심 개념인 state를 알아볼 것이다.
 */