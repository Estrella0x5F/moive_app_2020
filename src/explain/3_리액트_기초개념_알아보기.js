/* - 명령어로 리액트 앱을 실행했을 때 터미널을 종료하면 리액트 앱도 같이 종료되므로 실시간으로 코드를
 * 수정하고 크롬 브라우저에 반영된 결과를 확인하려면 터미널을 종료하면 안 된다. 만약 터미널을 종료한
 * 뒤 실행중이던 크롬 브라우저를 새로고침하면 사이트에 연결할 수 없다는 오류가 발생하게 된다. 
 * App() 함수의 반환값이 많아질 경우 이를 소괄호로 감싸야 함에 유의한다. 
 * 
 * [컴포넌트]
 * - (TS에서는 모듈이라고 하는 것)리액트의 컴포넌트가 무엇인지에 대해 알아보자. App.js 파일의 App()
 * 함수와 App() 함수가 반환하는 값을 확인해 보자. App() 함수가 정의되어 있고, 이 함수가 태그로 감싸-
 * 진 문자열을 반환하고 있는데, 이것이 바로 App 컴포넌트를 정의한 것이다. App() 함수가 반환한 HTML이
 * 리액트 앱 화면에 그려지는 것이다. 
 * 
 * [index.js 파일로 컴포넌트의 사용 알아보기]
 * - index.js 파일을 다시 한번 열어 보자. 그리고 <App />이라고 입력한 내용에 집중하자. 
 * 파일 상단의 'import App from './App''부분이 바로 App 컴포넌트를 임포트하여 사용한 것이다. App 컴-
 * 포넌트 생김새가 마치 html 태그 같지만 html에는 App이라는 이름의 태그가 없다. <App />을 ReactDOM.
 * render() 함수의 첫 번째 인자로 전달하면 App 컴포넌트가 반환하는 것들을 화면에 그릴 수 있다. App
 * 컴포넌트가 그려질 위치는 ReactDOM.render() 함수의 두 번째 인자로 전달하면 된다. 함수를 그대로 해-
 * 석해서 'App 컴포넌트는 아이디가 root인 엘리먼트에 그려질 것이다.' 저도로 이해하면 된다. 아이다가
 * root인 엘리먼트는 index.html에 있는데 이것도 곧 살펴볼 것이다. 
 * 리액트는 <App /> 과 같은 표시를 컴포넌트로 인식하고, 그 컴포넌트가 반환하는 값을 화면에 그려 준다. 
 * 리액트는 <App />과 같은 표시를 컴포넌트로 인식하고, 그 컴포넌트가 반환하는 값을 화면에 그려준다. 
 * (달리 말하면, 반환을 명시하지 않는경우 그 컴포넌트는 아무 짝에도 쓸모없어진다는 뜻이다. 렌더링 목-
 * 적이 아닌 다른 용도로 사용하는 경우는 제외. 미리 다른 책으로 먼저 배워놔서 그런지 원리에 대한 이해
 * 가 매우 쉽다). 여기서 집중할 내용은 리액트는 컴포넌트와 함께 동작하고, 리액트 앱은 모두 컴포넌트로
 * 구성된다는 것이다. 그러니 앞으로 영화 앱을 클론 코딩할 때는 컴포넌트를 많이 만들고 또 사용할 것이-
 * 다. 클론 코딩 수업을 진행하다 보면 '컴포넌트'는 우리들이 좋아하는 단어가 될 것이다. 지금부터 컴포-
 * 넌트를 정의하거나 사용할 때는 그냥 모두 '컴포넌트'라 부르겠다. 
 * 
 * [JSX]
 * - 컴포넌트를 만들 때는 JS와 HTML을 조합한 JSX라는 문법을 사용해서 만든다. JSX라고 하니 뭔가 특별해
 * 보이지만 그저 JS와 HTML을 조합했을 뿐이다. 따라서 기존에 사용하던 JS와 HTML과 문법이 거의 비슷하다. 
 * 다만 둘을 같이 조합함으로써 생긴 JS와 HTML간의 겹치는 키워드나 요소들로 인해 약간의 차이가 존재한-
 * 다. 이는 JSX를 사용해가면서 차근차근 배워 볼 것이다. 
 * JSX로 예시 컴포넌트를 만들어 보자. 우선 src 디렉토리에 Potato.js 라는 파일을 만들어보자. 
 * 리액트가 JSX를 이해하려면 맨 위에 'import React from 'react''를 입력해야 한다(이게 리액트의 영향-
 * 권에 있는지 그냥 평범한 JS 파일인지 구분하기 위함인듯). 이제 컴포넌트를 정의해볼 차례이다. 다음과
 * 같이 Potato() 함수를 작성해 보자.
 * Potato 컴포넌트의 기본 틀이 완성되었다. 컴포넌트를 작성할 때 중요한 규칙은 이름이 대문자로 시작해-
 * 야 한다는 점이다. 
 * Potato가 JSX를 반환하도록 해 보자. 아직 JS 코드를 조합하지 않았을 뿐, Potato()는 JSX를 반환하고 
 * 있다. 다 작성했다면 'export default Potato'를 맨 아래에 추가하자. 이 문구는 다른 파일에서 Potato
 * 컴포넌트를 사용할 수 있게 한다. 이제 완성한 컴포넌트를 사용해 보자. 
 * 
 * [Potato 컴포넌트 사용하기]
 * - index.js 파일을 열어서 Potato 컴포넌트를 어떻게 사용할지 잠시 코드를 살펴보자. 
 * App 컴포넌트가 사용된 부분에 Potato 컴포넌트를 추가하면 될 것 같은데, 한번 시도해 보자. 
 * 기대와 다르게 오류가 발생한다. 오류 메시지를 읽어 보면 '인접한 JSX 요소는 반드시 하나의 태그로 감-
 * 싸야 합니다.' 라고 말하고 있다. 리액트는 최종적으로 단 한개의 컴포넌트를 그려야 하는데, 지금은
 * 두 개의 컴포넌트를 그리려 해서 오류가 발생했다. 렌더링 속도의 향상을 위해 리액트 컴포넌트는 반드-
 * 시 트리 형태의 구조로 작성하도록 되어있기 때문이다. 
 * 이제 Potato 컴포넌트를 App 컴포넌트에서 import 한 뒤 추가해 보자. 
 * App 컴포넌트에 JSX로 작성한 기존 컴포넌트와 Potato 컴포넌트가 같이 출력되었다. Potato 컴포넌트가
 * 어떻게 출력되었는지 개발자 도구에서 확인해 보자. 
 * 크롬 개발자 도구를 실행한 다음 Element 탭을 열어 코드를 살펴보자. body 엘리먼트 왼쪽에 있는 삼각형
 * 표시를 누르면 코드를 펼쳐볼 수 있다. 
 * 리액트가 <Potato />를 해석해서 해당 컴포넌트를 화면에 표시했다. 이것이 컴포넌트와 JSX가 리액트에서
 * 동작하는 방식이다. 컴포넌트는 JSX로 만들고, JSX는 JS와 HTML을 조합한 문법을 사용한다는 말이 이제
 * 약간 이해될 것이다. 다음 실습으로 넘어가기 전에 파일을 정리하자. 
 * App 파일 맨 위에 있는 Potato 컴포넌트를 import하는 문구를 주석처리한 뒤 리액트 앱 페이지를 새로고-
 * 침해 보면 오류 메시지가 출력된다. 내용은 'App.js 파일에 Potato라는 것이 정의되지 않아서 컴파일에
 * 실패했다'는 내용이다. Potato 컴포넌트를 불러오는 구문을 주석처리했지만 App.js 파일에서는 아직 Pot-
 * ato 컴포넌트를 사용하고 있기 때문에 발생한 오류이다. 
 * 이제 이 오류를 해결하기 위해 App.js 파일 안에 Potato 컴포넌트를 만든 다음 Potato 컴포넌트를 사용-
 * 해 보자. 
 * (아, App.js 파일 외부에 선언된 컴포넌트 뿐만 아니라 내부에 선언된 컴포넌트도 태그를 이용해 표시할
 * 수 있구나. 이건 몰랐네)파일을 저장하면 리액트 앱이 다시 정상적으로 작동하는 것을 알 수 있다. 이처-
 * 럼 외부에서 불러온 컴포넌트 뿐만 아니라 App.js 파일 내부에서 정의한 컴포넌트들도 태그를 이용해
 * 사용할 수 있다. 개발자의 성향에 따라 App.js 파일 안에 오로지 App() 함수만 남겨두거나, 짧은 코드로
 * 작성할 수 있는 컴포넌트에 한해 App.js 파일 안에 별도로 정의하는 경우도 있다. 본 교재에서는 크기가
 * 작은 컴포넌트들은 모두 App 컴포넌트 안에 작성할 것이다. 이렇게 하면 여러 개의 파일을 드나들며 작-
 * 업해야 하는 불편함이 줄어든다는 장점이 있다. 
 * 이번 액션에서는 Food 컴포넌트를 4개 사용해 각 컴포넌트에 전달한 fav props를 출력했다. 각각의 fav
 * props에는 서로 다른 값이 들어 있으니까 같은 컴포넌트를 사용해도 서로 다른 문장이 출력된 것이다. 
 * 이걸 컴포넌트를 재사용한다고도 하며, 각 항목에 일일이 대응하는 컴포넌트를 작성할 필요 없이 하나의
 * 컴포넌트를 이용하여 여러 항목을 출력하는 것이 가능하다. 
 * 
 */